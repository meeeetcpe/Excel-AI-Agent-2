// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const fspath = require("path");
const registry = require("./dev-settings-registry");
const defaultRuntimeLogFileName = "OfficeAddins.log.txt";
var DebuggingMethod;
(function (DebuggingMethod) {
    DebuggingMethod[DebuggingMethod["Direct"] = 0] = "Direct";
    DebuggingMethod[DebuggingMethod["Proxy"] = 1] = "Proxy";
    /** @deprecated use Proxy */
    DebuggingMethod[DebuggingMethod["Web"] = 1] = "Web";
})(DebuggingMethod = exports.DebuggingMethod || (exports.DebuggingMethod = {}));
class SourceBundleUrlComponents {
    get url() {
        const host = (this.host !== undefined) ? this.host : "localhost";
        const port = (this.port !== undefined) ? this.port : "8081";
        const path = (this.path !== undefined) ? this.path : "{path}";
        const extension = (this.extension !== undefined) ? this.extension : ".bundle";
        return `http://${host}${host && port ? ":" : ""}${port}/${path}${extension}`;
    }
    constructor(host, port, path, extension) {
        this.host = host;
        this.port = port;
        this.path = path;
        this.extension = extension;
    }
}
exports.SourceBundleUrlComponents = SourceBundleUrlComponents;
function clearDevSettings(addinId) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (process.platform) {
            case "win32":
                return registry.clearDevSettings(addinId);
            default:
                throw new Error(`Platform not supported: ${process.platform}.`);
        }
    });
}
exports.clearDevSettings = clearDevSettings;
function disableDebugging(addinId) {
    return __awaiter(this, void 0, void 0, function* () {
        return enableDebugging(addinId, false);
    });
}
exports.disableDebugging = disableDebugging;
function disableLiveReload(addinId) {
    return __awaiter(this, void 0, void 0, function* () {
        return enableLiveReload(addinId, false);
    });
}
exports.disableLiveReload = disableLiveReload;
function disableRuntimeLogging() {
    return __awaiter(this, void 0, void 0, function* () {
        switch (process.platform) {
            case "win32":
                return registry.disableRuntimeLogging();
            default:
                throw new Error(`Platform not supported: ${process.platform}.`);
        }
    });
}
exports.disableRuntimeLogging = disableRuntimeLogging;
function enableDebugging(addinId, enable = true, method = DebuggingMethod.Direct) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (process.platform) {
            case "win32":
                return registry.enableDebugging(addinId, enable, method);
            default:
                throw new Error(`Platform not supported: ${process.platform}.`);
        }
    });
}
exports.enableDebugging = enableDebugging;
function enableLiveReload(addinId, enable = true) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (process.platform) {
            case "win32":
                return registry.enableLiveReload(addinId, enable);
            default:
                throw new Error(`Platform not supported: ${process.platform}.`);
        }
    });
}
exports.enableLiveReload = enableLiveReload;
function enableRuntimeLogging(path) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (process.platform) {
            case "win32":
                if (!path) {
                    const tempDir = process.env.TEMP;
                    if (!tempDir) {
                        throw new Error("The TEMP environment variable is not defined.");
                    }
                    path = fspath.normalize(`${tempDir}/${defaultRuntimeLogFileName}`);
                }
                const pathExists = fs.existsSync(path);
                if (pathExists) {
                    const stat = fs.statSync(path);
                    if (stat.isDirectory()) {
                        throw new Error(`You need to specify the path to a file. This is a directory: "${path}".`);
                    }
                }
                try {
                    const file = fs.openSync(path, "a+");
                    fs.closeSync(file);
                }
                catch (err) {
                    throw new Error(pathExists
                        ? `You need to specify the path to a writable file. Unable to write to: "${path}".`
                        : `You need to specify the path where the file can be written. Unable to write to: "${path}".`);
                }
                yield registry.enableRuntimeLogging(path);
                return path;
            default:
                throw new Error(`Platform not supported: ${process.platform}.`);
        }
    });
}
exports.enableRuntimeLogging = enableRuntimeLogging;
function getSourceBundleUrl(addinId) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (process.platform) {
            case "win32":
                return registry.getSourceBundleUrl(addinId);
            default:
                throw new Error(`Platform not supported: ${process.platform}.`);
        }
    });
}
exports.getSourceBundleUrl = getSourceBundleUrl;
function getEnabledDebuggingMethods(addinId) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (process.platform) {
            case "win32":
                return registry.getEnabledDebuggingMethods(addinId);
            default:
                throw new Error(`Platform not supported: ${process.platform}.`);
        }
    });
}
exports.getEnabledDebuggingMethods = getEnabledDebuggingMethods;
function getRuntimeLoggingPath() {
    return __awaiter(this, void 0, void 0, function* () {
        switch (process.platform) {
            case "win32":
                return registry.getRuntimeLoggingPath();
            default:
                throw new Error(`Platform not supported: ${process.platform}.`);
        }
    });
}
exports.getRuntimeLoggingPath = getRuntimeLoggingPath;
function isDebuggingEnabled(addinId) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (process.platform) {
            case "win32":
                return registry.isDebuggingEnabled(addinId);
            default:
                throw new Error(`Platform not supported: ${process.platform}.`);
        }
    });
}
exports.isDebuggingEnabled = isDebuggingEnabled;
function isLiveReloadEnabled(addinId) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (process.platform) {
            case "win32":
                return registry.isLiveReloadEnabled(addinId);
            default:
                throw new Error(`Platform not supported: ${process.platform}.`);
        }
    });
}
exports.isLiveReloadEnabled = isLiveReloadEnabled;
function setSourceBundleUrl(addinId, components) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (process.platform) {
            case "win32":
                return registry.setSourceBundleUrl(addinId, components);
            default:
                throw new Error(`Platform not supported: ${process.platform}.`);
        }
    });
}
exports.setSourceBundleUrl = setSourceBundleUrl;
//# sourceMappingURL=dev-settings.js.map